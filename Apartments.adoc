= Apartments

Les sites de location (type https://www.pap.fr) proposent généralement des moyens rudimentaires de recherche parmi les annonces existantes. Ce projet vise à doter l’utilisateur de moyens d’indiquer ses préférences d’une manière riche, afin de lui montrer les annonces qui lui conviennent le mieux d’abord. En particulier, au lieu de filtrer de façon binaire (ex. : inclure un appartement seulement s’il fait au moins x m²), le système permettra la compensation (ex. : inclure une annonce pour un appartement très petit s’il est très bon sur les autres critères) ; et le système permettra d’inclure comme critère la distance (en transport public) à des lieux d’intérêts pour l’utilisateur tels que son lieu de travail.

On repartira d’un https://github.com/oliviercailloux/Apartments[projet] existant.

== Commencer par
* Mettre à jour dépendances, vérifier config JUnit 5 et Guava en particulier
* Nettoyer dépôt : gitignore, déplacer doc (t.q. ancienne présentation) dans un répertoire `Doc`, enlever éventuels fichiers inutiles
* Prendre en compte warnings Eclipse.
* Lister ce qui est fait parmi les fonctions ci-dessous, fait mais à revoir (pourquoi), non fait
* Améliorer lisibilité du code, utiliser des objets immuables là où c’est censé (par sujet)

== Fonctions demandées précédemment
(Les nombres entre parenthèses donnent une vague idée du temps nécessaire pour l’implémentation, 3 est estimé à trois fois plus long que 1.)

Contract1:: Une classe qui permet de stocker des caractéristiques qu’on peut trouver dans une annonce (simple !) pour un appartement : superficie, adresse (utilisez un String par exemple), nombre de chambres, texte complet, et quelques autres attributs de votre choix. (0,5)
Contract2:: Une classe PiecewiseLinearValueFunction, qui permet de stocker un ensemble de paires (valeur réelle, valeur réelle entre 0 et 1 compris). Une instance de cette classe permet de mesurer l’attrait pour l’utilisateur d’un aspect donné d’un appartement. La première valeur représente une description objective de la qualité d’un appartement sur un aspect donné (par exemple la taille de l’appartement), et la deuxième, entre 0 et 1, mesure l’attrait associée à cette qualité. Cette mesure est nommée la valeur subjective, ou utilité, correspondant à la valeur objective fournie. La classe permet donc d’associer à différentes valeurs objectives leur utilité. Par exemple, on pourra associer la valeur 30 (mètre carrés) à l’utilité 0.5 et la valeur 45 (mètres carrés) à l’utilité 0.7. Vous pouvez repartir de https://github.com/elieahd/decision-uta-method/blob/master/src/main/java/io/github/oliviercailloux/uta_calculator/model/PartialValueFunction.java[PartialValueFunction.java] dans le projet UTA Calculator (à condition de citer vos sources, bien sûr). (1)
File1:: Une classe qui permet de lire des appartements au format Java XML properties (voir https://docs.oracle.com/javase/9/docs/api/java/util/Properties.html#loadFromXML-java.io.InputStream-[Properties#loadFromXML]). Elle comportera entre autres une méthode d’en-tête suivant : `public Apartment readApartment(InputStream input) throws IOException`. (1)
File2:: Une classe qui permet d’écrire un appartement au format Java XML properties. (1)
Resources1:: Inclure dans votre projet une icône illustrant votre projet de façon à ce qu’elle soit accessible dans le class path. Créer une méthode main qui crée une fenêtre principale (vide) et affiche l’icône à l’aide de SWT (https://www.safaribooksonline.com/library/view/swt-a-developers/0596008384/ch02s09.html[Exemple], auquel il faut ajouter un appel à `dispose` pour se débarrasser de l’image en fin de programme). (1)
Resources2:: Inclure dans votre class path un fichier start-apartment-classpath.xml qui contient un appartement connu au démarrage de l’application. Créer un fichier start-apartment.xml à la racine de votre projet, contenant un appartement différent. Créer un main qui affiche ces deux appartements sur la sortie standard. (1)
Interfaces1:: Créer une Interface Java `PartialValueFunction`, paramétée par le type de donnée objective, pour représenter l’association entre des données objectives et des utilités : on lui fournit une donnée objective (par exemple une couleur) et elle retourne la valeur subjective associée, entre 0 et 1. (Idéalement, votre interface étendra `Function<T, Double>`, où `T` est votre paramètre de type.) Fusionner dans master. Dans la branche Interfaces1.1, créer une classe `ValueFunction`. On peut lui fournir deux instances de `PartialValueFunction` (avec des paramètres de type `String` et `Double`). On peut aussi lui fournir deux données objectives, un `String` et un `double`. Elle renvoie un résultat composé de la somme des valeurs renvoyées par les deux instances de `PartialValueFunction` pour les données objectives fournies. Faites en sorte que la branche Interfaces1.1 ne contienne pas d’implémentation de `PartialValueFunction`. (1,5)
Interfaces2:: Une classe `LinearValueFunction` qui implémente `PartialValueFunction<Double>`. On lui fournit un intervalle (par exemple [10, 50]) qui définit les points renvoyant zéro et un. Si on communique un autre nombre à la fonction entre 10 et 50, elle interpole linéairement (par exemple 20 renverrait (20−10)/(50−10)=0.25). Une classe `Discrete3ValueFunction` qui implémente `PartialValueFunction<String>`, à laquelle on fournit trois strings, le premier associé à la valeur subjective zéro, le deuxième à 0.5 et le troisième à 1. Fusionner Interfaces2 et Interfaces1.1 dans master. Dans la branche Interfaces 2.1, créer une méthode main qui utilise `ValueFunction`, `LinearValueFunction` et `Discrete3ValueFunction` pour calculer la valeur associée à un String et un double de votre choix. (1,5)
Gener:: Généraliser vos fonctions de valeur subjective. `DiscreteValueFunction<T>` reçoit des paires de données (T, Double) et renvoie les valeurs correspondantes. Modifier `ValueFunction`, et la renommer `ApartmentValueFunction`, pour qu’elle contienne autant de fonctions de valeurs partielles que d’aspects à mesurer dans un appartement : une pour la taille, une pour le nombre de pièces, etc. La classe admet, de plus, un poids (un nombre réel non négatif) pour chaque aspect. Elle reçoit un appartement au lieu d’un string et un double, et renvoie la valeur de l’appartement en utilisant comme données objectives les données de l’appartement. Au moment de calculer la valeur, elle effectue une somme pondérée au lieu d’une somme simple. Les poids sont par défaut tous égaux. (2)
Dist:: Une classe qui utilise l’API de Google Map pour obtenir la distance entre deux lieux en métro. (2)
GUI:: Un GUI qui permet de créer ou d’éditer une nouvelle annonce, sauvée dans un fichier (de nom fourni en paramètre du programme). (3)
ValueDist:: Un appartement a une localisation précise (pour la stocker, utiliser un type permettant de représenter un endroit précis sur le globe, cf. fct précédente). Une implémentation de `PartialValueFunction<Location>`, avec `Location` le type choisi pour stocker la localisation, calcule l’utilité de la localisation : l’instance reçoit des lieux d’intérêts de l’utilisateur (par défaut, le centre de Paris), calcule le max des distances entre l’appartement et tous les lieux d’intérêts, et renvoie une interpolation linéaire avec 1 pour une distance de 0, et 0 pour une distance de 10h. (1)

== Autres fonctionnalités
* Lecture et écriture d’un appartement dans et depuis un fichier XML, au format https://github.com/xmcda-modular/[xmcda-modular]. Utiliser un élément XML Alternative pour identifier l’appartement, un élément Criterion pour chaque aspect (taille, etc.), et un élément Evaluation pour indiquer les valeurs objectives décrivant l’appartement. Voir https://github.com/xmcda-modular/schema[example]. (2)
* Lecture et écriture d’une `PartialValueFunction` au format xmcda-modular. (2) 
* Lecture et écriture d’une `ApartmentValueFunction` au format xmcda-modular. (2) 
* GUI qui montre à l’utilisateur tous les appartements disponibles dans un répertoire donné en paramètre, triés selon l’utilité de l’utilisateur (fournie dans un fichier dans le même répertoire). L’utilisateur peut cliquer sur un appartement et voit sa description. (2)
* Extraction d’annonces depuis pap. (2)
* Alertes : l’utilisateur indique à quel niveau d’utilité il veut être alerté en cas d’apparition d’une nouvelle annonce intéressante.
* L’utilisateur indique son utilité de localisation par rapport à plusieurs lieux.
* L’utilisateur se fait aider pour déterminer son utilité. Il voit le résultat de sa spécification d’utilité sur des annonces concrètes du système.
* L’utilisateur peut indiquer en voyant la liste d’annonces qu’il préfère une annonce à une autre alors qu’elle est classé sous la deuxième. Le système lui permet alors de corriger son utilité pour que le classement en question soit rétabli.

== Sources
* https://www.pap.fr : semblent ouverts.
* https://www.seloger.com/ : verrouillage légal. (« En accédant au Site Internet de la Société, l'Utilisateur déclare, garantit et s'engage à (…) ne pas utiliser de dispositifs ou logiciels autres que ceux fournis par la Société destinés à (…) extraire, modifier, consulter, même en mémoire tampon ou temporaire, ou encore pour une utilisation individualisée, tout ou partie du Site Internet »)
* AirBnB : verrouillage légal. (https://www.airbnb.fr/terms, Conduite de l'Utilisateur)

